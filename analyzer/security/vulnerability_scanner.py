"""
Security vulnerability scanner.

Detects potential security vulnerabilities:
- SQL Injection
- Command Injection
- Path Traversal
- XSS
- Insecure Deserialization
"""

import ast
import re
from dataclasses import dataclass, field
from typing import Optional
from enum import Enum

from analyzer.models.code_entities import Module
from analyzer.logging_config import get_logger

logger = get_logger("security.vulnerabilities")


class VulnerabilityType(Enum):
    """Types of security vulnerabilities."""
    SQL_INJECTION = "sql_injection"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    XSS = "xss"
    INSECURE_DESERIALIZATION = "insecure_deserialization"
    INSECURE_RANDOM = "insecure_random"
    HARDCODED_PASSWORD = "hardcoded_password"
    EVAL_USAGE = "eval_usage"
    EXEC_USAGE = "exec_usage"
    SHELL_INJECTION = "shell_injection"
    UNSAFE_YAML = "unsafe_yaml"
    INSECURE_HASH = "insecure_hash"
    DEBUG_ENABLED = "debug_enabled"


class Severity(Enum):
    """Vulnerability severity levels."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class Vulnerability:
    """A detected security vulnerability."""
    vuln_type: VulnerabilityType
    severity: Severity
    message: str
    file_path: str
    line_number: int
    code_snippet: Optional[str] = None
    cwe_id: Optional[str] = None
    recommendation: Optional[str] = None
    
    def to_dict(self) -> dict:
        return {
            "type": self.vuln_type.value,
            "severity": self.severity.value,
            "message": self.message,
            "file": self.file_path,
            "line": self.line_number,
            "snippet": self.code_snippet,
            "cwe": self.cwe_id,
            "recommendation": self.recommendation,
        }


class VulnerabilityScanner:
    """Scans code for security vulnerabilities."""
    
    # Dangerous function patterns
    DANGEROUS_FUNCTIONS = {
        'eval': (VulnerabilityType.EVAL_USAGE, Severity.HIGH, 'CWE-95'),
        'exec': (VulnerabilityType.EXEC_USAGE, Severity.HIGH, 'CWE-95'),
        'compile': (VulnerabilityType.EVAL_USAGE, Severity.MEDIUM, 'CWE-95'),
        '__import__': (VulnerabilityType.INSECURE_DESERIALIZATION, Severity.MEDIUM, 'CWE-502'),
    }
    
    # SQL-related patterns
    SQL_PATTERNS = [
        r'execute\s*\(\s*["\'].*%s',
        r'execute\s*\(\s*["\'].*\+',
        r'execute\s*\(\s*f["\']',
        r'cursor\.execute\s*\(\s*["\'].*format',
        r'\.raw\s*\(\s*["\'].*%s',
    ]
    
    # Command injection patterns
    COMMAND_FUNCTIONS = {
        'os.system': (VulnerabilityType.COMMAND_INJECTION, Severity.CRITICAL),
        'os.popen': (VulnerabilityType.COMMAND_INJECTION, Severity.CRITICAL),
        'subprocess.call': (VulnerabilityType.SHELL_INJECTION, Severity.HIGH),
        'subprocess.run': (VulnerabilityType.SHELL_INJECTION, Severity.MEDIUM),
        'subprocess.Popen': (VulnerabilityType.SHELL_INJECTION, Severity.MEDIUM),
    }
    
    # Insecure hash algorithms
    INSECURE_HASHES = {'md5', 'sha1'}
    
    def scan(self, modules: list[Module]) -> list[Vulnerability]:
        """
        Scan modules for vulnerabilities.
        
        Args:
            modules: List of parsed modules
            
        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []
        
        for module in modules:
            vulnerabilities.extend(self._scan_module(module))
        
        return vulnerabilities
    
    def scan_code(self, code: str, file_path: str = "<string>") -> list[Vulnerability]:
        """Scan code string for vulnerabilities."""
        vulnerabilities = []
        
        try:
            tree = ast.parse(code)
            vulnerabilities.extend(self._scan_ast(tree, code, file_path))
        except SyntaxError:
            pass
        
        return vulnerabilities
    
    def _scan_module(self, module: Module) -> list[Vulnerability]:
        """Scan a module for vulnerabilities."""
        vulnerabilities = []
        
        # Check function calls for dangerous patterns
        for func in module.functions:
            vulnerabilities.extend(self._check_function_calls(func, module.file_path))
        
        for cls in module.classes:
            for method in cls.methods:
                vulnerabilities.extend(self._check_function_calls(method, module.file_path))
        
        return vulnerabilities
    
    def _check_function_calls(self, func, file_path: str) -> list[Vulnerability]:
        """Check function calls for security issues."""
        vulnerabilities = []
        
        for call in func.calls:
            # Check dangerous functions
            if call in self.DANGEROUS_FUNCTIONS:
                vuln_type, severity, cwe = self.DANGEROUS_FUNCTIONS[call]
                vulnerabilities.append(Vulnerability(
                    vuln_type=vuln_type,
                    severity=severity,
                    message=f"Use of dangerous function: {call}",
                    file_path=file_path,
                    line_number=func.location.start_line,
                    cwe_id=cwe,
                    recommendation=f"Avoid using {call}. Use safer alternatives.",
                ))
            
            # Check command injection
            if call in self.COMMAND_FUNCTIONS:
                vuln_type, severity = self.COMMAND_FUNCTIONS[call]
                vulnerabilities.append(Vulnerability(
                    vuln_type=vuln_type,
                    severity=severity,
                    message=f"Potential command injection via {call}",
                    file_path=file_path,
                    line_number=func.location.start_line,
                    cwe_id="CWE-78",
                    recommendation="Use subprocess with shell=False and pass args as list",
                ))
            
            # Check insecure hashing
            if any(h in call.lower() for h in self.INSECURE_HASHES):
                vulnerabilities.append(Vulnerability(
                    vuln_type=VulnerabilityType.INSECURE_HASH,
                    severity=Severity.MEDIUM,
                    message=f"Use of insecure hash algorithm: {call}",
                    file_path=file_path,
                    line_number=func.location.start_line,
                    cwe_id="CWE-328",
                    recommendation="Use SHA-256 or stronger hash algorithms",
                ))
            
            # Check insecure random
            if call in ('random.random', 'random.randint', 'random.choice'):
                vulnerabilities.append(Vulnerability(
                    vuln_type=VulnerabilityType.INSECURE_RANDOM,
                    severity=Severity.LOW,
                    message=f"Non-cryptographic random used: {call}",
                    file_path=file_path,
                    line_number=func.location.start_line,
                    cwe_id="CWE-330",
                    recommendation="Use secrets module for security-sensitive random values",
                ))
        
        return vulnerabilities
    
    def _scan_ast(self, tree: ast.AST, code: str, file_path: str) -> list[Vulnerability]:
        """Scan AST for vulnerabilities."""
        vulnerabilities = []
        lines = code.splitlines()
        
        for node in ast.walk(tree):
            # Check for eval/exec
            if isinstance(node, ast.Call):
                vulnerabilities.extend(self._check_call_node(node, file_path, lines))
            
            # Check for SQL string formatting
            if isinstance(node, ast.BinOp) and isinstance(node.op, ast.Mod):
                # String formatting with %
                vulnerabilities.extend(self._check_sql_formatting(node, file_path))
            
            # Check for shell=True in subprocess
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                vulnerabilities.extend(self._check_subprocess(node, file_path))
            
            # Check for pickle/yaml.load
            if isinstance(node, ast.Call):
                vulnerabilities.extend(self._check_deserialization(node, file_path))
        
        return vulnerabilities
    
    def _check_call_node(
        self, 
        node: ast.Call, 
        file_path: str,
        lines: list[str]
    ) -> list[Vulnerability]:
        """Check a call node for vulnerabilities."""
        vulnerabilities = []
        
        func_name = self._get_call_name(node)
        
        if func_name in ('eval', 'exec'):
            code_snippet = lines[node.lineno - 1].strip() if lines else None
            
            vulnerabilities.append(Vulnerability(
                vuln_type=VulnerabilityType.EVAL_USAGE if func_name == 'eval' else VulnerabilityType.EXEC_USAGE,
                severity=Severity.HIGH,
                message=f"Dangerous use of {func_name}()",
                file_path=file_path,
                line_number=node.lineno,
                code_snippet=code_snippet,
                cwe_id="CWE-95",
                recommendation=f"Remove {func_name}() or use ast.literal_eval() for simple cases",
            ))
        
        return vulnerabilities
    
    def _check_sql_formatting(self, node: ast.BinOp, file_path: str) -> list[Vulnerability]:
        """Check for SQL injection via string formatting."""
        vulnerabilities = []
        
        # Check if left side contains SQL keywords
        if isinstance(node.left, ast.Constant) and isinstance(node.left.value, str):
            sql_keywords = ['select', 'insert', 'update', 'delete', 'where', 'from']
            if any(kw in node.left.value.lower() for kw in sql_keywords):
                vulnerabilities.append(Vulnerability(
                    vuln_type=VulnerabilityType.SQL_INJECTION,
                    severity=Severity.CRITICAL,
                    message="Potential SQL injection via string formatting",
                    file_path=file_path,
                    line_number=node.lineno,
                    cwe_id="CWE-89",
                    recommendation="Use parameterized queries instead of string formatting",
                ))
        
        return vulnerabilities
    
    def _check_subprocess(self, node: ast.Call, file_path: str) -> list[Vulnerability]:
        """Check subprocess calls for shell injection."""
        vulnerabilities = []
        
        func_name = self._get_call_name(node)
        
        if 'subprocess' in func_name:
            # Check for shell=True
            for keyword in node.keywords:
                if keyword.arg == 'shell':
                    if isinstance(keyword.value, ast.Constant) and keyword.value.value:
                        vulnerabilities.append(Vulnerability(
                            vuln_type=VulnerabilityType.SHELL_INJECTION,
                            severity=Severity.HIGH,
                            message="subprocess called with shell=True",
                            file_path=file_path,
                            line_number=node.lineno,
                            cwe_id="CWE-78",
                            recommendation="Avoid shell=True. Pass command as list instead.",
                        ))
        
        return vulnerabilities
    
    def _check_deserialization(self, node: ast.Call, file_path: str) -> list[Vulnerability]:
        """Check for insecure deserialization."""
        vulnerabilities = []
        
        func_name = self._get_call_name(node)
        
        # Pickle
        if func_name in ('pickle.load', 'pickle.loads', 'cPickle.load', 'cPickle.loads'):
            vulnerabilities.append(Vulnerability(
                vuln_type=VulnerabilityType.INSECURE_DESERIALIZATION,
                severity=Severity.HIGH,
                message="Use of pickle for deserialization",
                file_path=file_path,
                line_number=node.lineno,
                cwe_id="CWE-502",
                recommendation="Avoid pickle for untrusted data. Use JSON or safe alternatives.",
            ))
        
        # Unsafe YAML
        if func_name == 'yaml.load':
            # Check if Loader is specified
            has_safe_loader = any(
                kw.arg == 'Loader' for kw in node.keywords
            )
            if not has_safe_loader:
                vulnerabilities.append(Vulnerability(
                    vuln_type=VulnerabilityType.UNSAFE_YAML,
                    severity=Severity.HIGH,
                    message="yaml.load() without safe Loader",
                    file_path=file_path,
                    line_number=node.lineno,
                    cwe_id="CWE-502",
                    recommendation="Use yaml.safe_load() or specify Loader=yaml.SafeLoader",
                ))
        
        return vulnerabilities
    
    def _get_call_name(self, node: ast.Call) -> str:
        """Get the name of a call."""
        if isinstance(node.func, ast.Name):
            return node.func.id
        elif isinstance(node.func, ast.Attribute):
            parts = []
            current = node.func
            while isinstance(current, ast.Attribute):
                parts.append(current.attr)
                current = current.value
            if isinstance(current, ast.Name):
                parts.append(current.id)
            return '.'.join(reversed(parts))
        return ""


def scan_vulnerabilities(modules: list[Module]) -> list[Vulnerability]:
    """
    Scan modules for security vulnerabilities.
    
    Args:
        modules: List of parsed modules
        
    Returns:
        List of detected vulnerabilities
    """
    scanner = VulnerabilityScanner()
    return scanner.scan(modules)
